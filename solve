#!/usr/bin/python3

import pysat.formula
import pysat.solvers
import sys
from cset import course_data

days = 'MTWRFSU'
def time_key(t):
    day = days.index(t[0])
    for (i, ch) in enumerate(t):
        if ch.isdigit():
            time = t[i:i+4]
            dur = int(t[i+5:])
            break
    return (dur*i, day, time, dur)


all_rooms = {
    triple[0]
        for elt in course_data.values()
        for triple in elt['room_times']
}
rooms_by_course = {
    course: { triple[0] for triple in value['room_times'] }
        for (course, value) in course_data.items()
}
rooms_in_order = sorted(all_rooms)

all_times = {
    triple[1]
        for elt in course_data.values()
        for triple in elt['room_times']
}
times_by_course = {
    course: { triple[1] for triple in value['room_times'] }
        for (course, value) in course_data.items()
}
times_in_order = sorted(all_times, key=time_key)
time_pairs = { (x, y) for x in all_times for y in all_times if x < y }

all_courses = set(course_data.keys())
course_pairs = { (x, y)
    for x in all_courses
    for y in all_courses

    if x < y
}

def parse_time(t):
    for (i, ch) in enumerate(t):
        if ch.isdigit():
            days = t[:i]
            start = int(t[i:i+2])*60 + int(t[i+2:i+4])
            end = start + int(t[i+5:])
            return (days, start, end)
    print(f'failed to parse {t}')
    sys.exit(1)

time_conflicts = { time: set() for time in all_times }
for (time_a, time_b) in time_pairs:
    days_a, start_a, end_a = parse_time(time_a)
    days_b, start_b, end_b = parse_time(time_b)
    if end_a <= start_b or end_b <= start_a: continue
    if len(set(days_a) & set(days_b)) > 0:
        time_conflicts[time_a] = { time_b }
        time_conflicts[time_b] = { time_a }

course_room_to_var = {}
var_to_course_room = {}
course_time_to_var = {}
var_to_course_time = {}
var_count = 1
clauses = []

def assign_vars():
    global var_count
    for course in all_courses:
        for room in rooms_by_course[course]:
            course_room_to_var[(course, room)] = var_count
            var_to_course_room[var_count] = (course, room)
            var_count += 1
    for course in all_courses:
        for time in times_by_course[course]:
            course_time_to_var[(course, time)] = var_count
            var_to_course_time[var_count] = (course, time)
            var_count += 1

def at_least_one_room_and_time_per_course():
    for course in all_courses:
        lst = [course_room_to_var[(course, room)] for room in rooms_by_course[course]]
        clauses.append(lst)
        lst = [course_time_to_var[(course, time)] for time in times_by_course[course]]
        clauses.append(lst)

def at_most_one_room_and_time_per_course():
    for course in all_courses:
        room_pairs = { (x, y)
            for x in rooms_by_course[course]
            for y in rooms_by_course[course]
            if x < y
        }
        for (room_a, room_b) in room_pairs:
            lst = [
                -course_room_to_var[(course, room_a)],
                -course_room_to_var[(course, room_b)],
            ]
            clauses.append(lst)

        time_pairs = { (x, y)
            for x in times_by_course[course]
            for y in times_by_course[course]
            if x < y
        }
        for (time_a, time_b) in time_pairs:
            lst = [
                -course_time_to_var[(course, time_a)],
                -course_time_to_var[(course, time_b)],
            ]
            clauses.append(lst)

def at_most_one_course_per_room_and_time():
    for (course_a, course_b) in course_pairs:
        for room in rooms_by_course[course_a] & rooms_by_course[course_b]:
            conflicting_times = { (x, y)
                for x in times_by_course[course_a]
                for y in times_by_course[course_b]

                if x == y or (x < y and x in time_conflicts[y])
            }
            for (time_a, time_b) in conflicting_times:
                lst = [
                    -course_room_to_var[(course_a, room)],
                    -course_time_to_var[(course_a, time_a)],
                    -course_room_to_var[(course_b, room)],
                    -course_time_to_var[(course_b, time_b)],
                ]
                clauses.append(lst)

def at_most_one_course_per_time_hard_conflicts():
    conflicting_courses = { (x, y)
        for x in all_courses
        for y in all_courses

        if x != y and x in course_data[y]['hard']
    }
    for (course_a, course_b) in conflicting_courses:
        conflicting_times = { (x, y)
            for x in times_by_course[course_a]
            for y in times_by_course[course_b]

            if x == y or x in time_conflicts[y]
        }
        for (time_a, time_b) in conflicting_times:
            lst = [
                -course_time_to_var[(course_a, time_a)],
                -course_time_to_var[(course_b, time_b)],
            ]
            clauses.append(lst)

def at_most_one_course_per_time_soft_conflicts(badness):
    conflicting_courses = { (x, y)
        for x in all_courses
        for y in all_courses

        if x != y and any(
            filter(lambda pair: pair[0] == y and pair[1] >= badness, course_data[x]['soft'])
        )
    }
    for (course_a, course_b) in conflicting_courses:
        conflicting_times = { (x, y)
            for x in times_by_course[course_a]
            for y in times_by_course[course_b]

            if x == y or x in time_conflicts[y]
        }
        for (time_a, time_b) in conflicting_times:
            lst = [
                -course_time_to_var[(course_a, time_a)],
                -course_time_to_var[(course_b, time_b)],
            ]
            clauses.append(lst)

def decode_solution(solution):
    placement = {}
    for course in all_courses:
        for room in rooms_by_course[course]:
            if course_room_to_var[(course, room)] in solution:
                break
        for time in times_by_course[course]:
            if course_time_to_var[(course, time)] in solution:
                break
        placement[course] = (room, time)
    return placement

def print_schedule(placement):
    grid = []
    for i in range(len(times_in_order) + 1):
        grid.append([''] * (len(rooms_in_order) + 1))
    for (i, room) in enumerate(rooms_in_order):
        grid[0][i+1] = room
    for (i, time) in enumerate(times_in_order):
        grid[i+1][0] = time
    for (course, (room, time)) in placement.items():
        grid[times_in_order.index(time)+1][rooms_in_order.index(room)+1] = course

    width = 1
    for time in times_in_order:
        width = max(len(time), width)
    for room in rooms_in_order:
        width = max(len(room), width)
    for course in all_courses:
        width = max(len(course), width)
    width += 2

    for (i, row) in enumerate(grid):
        div, elt = '+', '|'
        for column in row:
            div += '-'*width + '+'
            elt += f'{column:^{width}}|'
        if i == 0: print(div)
        print(elt)
        print(div)

def main():
    assign_vars()
    n = len(clauses)
    print('assigned', var_count, 'vars')
    at_least_one_room_and_time_per_course()
    print('at_least_one_room_and_time_per_course added', len(clauses) - n)
    n = len(clauses)
    at_most_one_room_and_time_per_course()
    print('at_most_one_room_and_time_per_course added', len(clauses) - n)
    n = len(clauses)
    at_most_one_course_per_room_and_time()
    print('at_most_one_course_per_room_and_time added', len(clauses) - n)
    n = len(clauses)
    at_most_one_course_per_time_hard_conflicts()
    print('at_most_one_course_per_time_hard_conflicts added', len(clauses) - n)
    n = len(clauses)
    at_most_one_course_per_time_soft_conflicts(32)
    print('at_most_one_course_per_time_soft_conflicts(32) added', len(clauses) - n)
    n = len(clauses)
    print('total of', n, 'clauses')

    cnf = pysat.formula.CNF(from_clauses=clauses)
    solver = pysat.solvers.Solver(bootstrap_with=cnf)
    if not solver.solve():
        print('Unsatisfiable')
        sys.exit(1)
    print()
    placement = decode_solution(solver.get_model())
    print_schedule(placement)

main()
